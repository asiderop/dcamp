#!/usr/bin/env python3

from subprocess import Popen, DEVNULL, STDOUT
from sys import stderr
from os.path import join, isdir, isfile
from os import mkdir
from signal import SIGINT

# config
NUM_GROUPS = 9
NODES_PER_HOST = 100
HOSTNAMES = [ 'localhost' ]
START_PORT = 50000
PORTS_PER_NODE = 10

HEARTBEAT = '5s'
METRICS = '''
[proc]
rate = 1s
threshold = *60s
metric = CPU

[disk]
rate = 10s
threshold = >500000
metric = DISK

[net]
rate = 10s
threshold = *120s
metric = NETWORK

[mem]
rate = 30s
metric = MEMORY
'''

# paths
BASE_DIR = '/Volumes/Repositories/Personal/dcamp'
DCAMP = join(BASE_DIR, 'bin/dcamp')
CONFIG = join(BASE_DIR, '.simulation.cfg')
DEBUG_DIR = join(BASE_DIR, 'debug/')

def log(msg):
	print(msg, file=stderr)

class Simulator(object):

	state = 'dead'
	nodes = {}
	root = None

	def __init__(self):
		if isfile(CONFIG):
			log("WARN: config file already exists; overwriting")

		for host in HOSTNAMES:
			port = START_PORT
			a = None
			for idx in range(NODES_PER_HOST):
				a = '%s:%d' % (host, port)
				self.nodes[a] = None
				port += PORTS_PER_NODE
			self.root = a  # we'll use the last address as root

		with open(CONFIG, 'w') as out:
			# root section
			out.write('[global]\nheartbeat = %s' % (HEARTBEAT))

			start_address = 0
			per_group = int(len(self.nodes) / NUM_GROUPS) + 1
			for idx in range(NUM_GROUPS):

				# group heading
				out.write('\n[group%d]\n' % idx)

				# group endpoint listings
				end_address = start_address + per_group
				if end_address > len(self.nodes):
					end_address = len(self.nodes)
				self.write_addresses(out, start_address, end_address)
				log('INFO: group %d has %d nodes' % (idx, end_address - start_address))
				start_address += per_group

				# group metrics
				out.write('\nproc\ndisk\nmem\nnet\n')

			# metric specs
			out.write(METRICS)

	def write_addresses(self, out, start, end):
		for address in list(self.nodes.keys())[start:end]:
			out.write(address + '\n')

	def launch(self):
		if 'dead' != self.state:
			return
		if not isdir(DEBUG_DIR):
			mkdir(DEBUG_DIR)
		log('INFO: launching %d nodes' % len(self.nodes))
		for a in self.nodes:
			assert self.nodes[a] is None
			fout = open(join(DEBUG_DIR, a + '.out'), 'w')
			p = Popen([DCAMP, '-d', 'base', '-a', a], stdout=fout, stderr=STDOUT)
			self.nodes[a] = (p, fout)
		self.state = 'ready'

	def start(self):
		if 'ready' != self.state:
			return
		Popen([DCAMP, '-d', 'root', '--start', '-f', CONFIG, '-a', self.root]).wait()
		self.state = 'running'

	def stop(self):
		if 'running' != self.state:
			return
		Popen([DCAMP, '-d', 'root', '--stop', '-f', CONFIG, '-a', self.root]).wait()
		self.state = 'ready'

	def kill(self, nodes=None):
		if 'dead' == self.state:
			return

		if nodes is None:
			nodes = self.nodes.keys()

		for a in nodes:
			if a in self.nodes and self.nodes[a] is not None:
				(p, fout) = self.nodes[a]
				p.send_signal(SIGINT)

		for a in nodes:
			if a in self.nodes and self.nodes[a] is not None:
				p.wait()
				fout.close()
				self.nodes[a] = None

		if nodes is None:
			self.state = 'dead'

	def run(self):
		try:
			while True:

				res = input("%s. what do? [launch|start|stop|kill]: " % self.state).split()

				action = ''
				args = None
				if len(res) > 0:
					action = res[0]
				if len(res) > 1:
					args = res[1:]

				if action not in ['launch', 'start', 'stop', 'kill']:
					log("ERRR: unknown option")

				# launch base nodes
				if 'launch' == action:
					self.launch()

				# start root node
				if 'start' == action:
					self.start()

				# stop root node
				if 'stop' == action:
					self.stop()

				# kill one/all nodes
				if 'kill' == action:
					self.kill(args)

		except KeyboardInterrupt:
			try:
				log('\nINFO: exiting...')
				self.kill()
			except KeyboardInterrupt:
				# maybe a process was blocked on a socket...kill it again
				log('\nINFO: really exiting...')
				self.kill()

		log("\nGood bye!")

s = Simulator()
s.run()
